import pygame
import random
import os
#from PIL import Image
import math
#import animation

# beige color rgb 247, 231, 206
# dark green rgb(44, 129, 2)
# dark blue rgb(23, 34, 85)

MAX_LEVEL = 10

# initializing
pygame.init()
WIDTH, HEIGHT = 950, 800
screen = pygame.display.set_mode((WIDTH, HEIGHT))

pygame.display.set_caption("Memory Card Game")

BUTTON_WIDTH, BUTTON_HEIGHT = 200, 50
BUTTON_GAP = 40

# paths and fonts
script_dir = os.path.dirname(os.path.abspath(__file__))
image_folder = os.path.join(script_dir, "images")
#font = pygame.font.SysFont('arial', 33)  
font= pygame.font.Font('Pixellettersful.ttf', 46)
#font= pygame.font.Font('KidsMagazine.ttf', 28)

# Load the image
logo = pygame.image.load('logo.png')

# constants
CARD_WIDTH, CARD_HEIGHT = 250, 250
MARGIN = 10
total_images = 7
used_images = set()

class Button:
    def __init__(self, text, x, y, width=300, height=100):
        self.rect = pygame.Rect(x, y, width, height)
        self.text = text
        self.color = (0, 200, 0)
        self.hover_color = (0, 255, 0)
    
    def draw(self, surface):
        mouse_pos = pygame.mouse.get_pos()
        color = self.hover_color if self.rect.collidepoint(mouse_pos) else self.color
        pygame.draw.rect(surface, color, self.rect, border_radius=5)
        text_surf = font.render(self.text, True, (255, 255, 255))
        text_rect = text_surf.get_rect(center=self.rect.center)
        surface.blit(text_surf, text_rect)

def get_level_images(level):

    if level < 2:
        pairs = 2

    elif level < 6:
        pairs = 3

    else:
        pairs = 6

    available = list(set(range(1, total_images + 1)) - used_images)
    if len(available) < pairs:
        used_images.clear()
        available = list(range(1, total_images + 1))
    selected = random.sample(available, pairs)
    used_images.update(selected)
    return [pygame.image.load(os.path.join(image_folder, f"{i}.png")).convert_alpha() for i in selected]

def calculate_centered_grid(card_count, screen_width, screen_height, card_width, card_height):
    best_cols = 1
    best_rows = card_count
    min_diff = card_count
    for cols in range(1, card_count + 1):
        rows = math.ceil(card_count / cols)
        grid_width = cols * (card_width + MARGIN) - MARGIN
        grid_height = rows * (card_height + MARGIN) - MARGIN
        if grid_width <= screen_width and grid_height <= screen_height:
            diff = abs(rows - cols)
            if diff < min_diff:
                min_diff = diff
                best_cols = cols
                best_rows = rows
    grid_width = best_cols * (card_width + MARGIN) - MARGIN
    grid_height = best_rows * (card_height + MARGIN) - MARGIN
    start_x = (screen_width - grid_width) // 2
    start_y = (screen_height - grid_height) // 2
    return best_rows, best_cols, start_x, start_y, grid_width, grid_height

def main():
    level = 0
    running = True
    clock = pygame.time.Clock()

    level_completed = False
    game_completed = False  

    cards = []
    card_states = []
    flipped_indices = []
    wait_time = 0
    rows, cols, start_x, start_y = 0, 0, 0, 0

    def initialize_level():
        nonlocal cards, card_states, flipped_indices, wait_time, level_completed, rows, cols, start_x, start_y, grid_width, grid_height
        images = get_level_images(level)
        cards = images * 2
        random.shuffle(cards)
        rows, cols, start_x, start_y, grid_width, grid_height = calculate_centered_grid(
            len(cards), 900, 750, CARD_WIDTH, CARD_HEIGHT
        )
        card_states = ["hidden"] * len(cards)
        flipped_indices = []
        wait_time = 0
        level_completed = False
        return rows, cols, start_x, start_y, grid_width, grid_height

    rows, cols, start_x, start_y, grid_width, grid_height = initialize_level()
    card_back = pygame.image.load(os.path.join(image_folder, 'back.png'))

    while running:
        screen.fill((247, 231, 206))

        if game_completed:
            congrats_text = font.render("Congratulations! You finished all levels!", True, (23, 34, 85))
            text_rect = congrats_text.get_rect(center=(screen.get_width() // 2, screen.get_height() // 2))
            screen.blit(congrats_text, text_rect)
            pygame.display.flip()
        else:
             # Display the image
            screen.blit(logo, (0, 0))
            # current level text
            level_text = font.render(f"Level {level + 1}", True, (23, 34, 85))
            screen.blit(level_text, (20, 20))

            # cards drawing
            for idx, card_img in enumerate(cards):
                row = idx // cols
                col = idx % cols
                x = start_x + col * (CARD_WIDTH + MARGIN)
                y = start_y + row * (CARD_HEIGHT + MARGIN)
                rect = pygame.Rect(x, y, CARD_WIDTH, CARD_HEIGHT)
                if card_states[idx] in ["matched", "flipped"]:
                    screen.blit(pygame.transform.scale(card_img, (CARD_WIDTH, CARD_HEIGHT)), rect.topleft)
                else:
                    screen.blit(pygame.transform.scale(card_back, (CARD_WIDTH, CARD_HEIGHT)), rect.topleft)

            # level completion check
            if not level_completed and all(state == "matched" for state in card_states):
                level_completed = True
                if level >= MAX_LEVEL - 1:
                    game_completed = True

            # drawing buttons
            if level_completed and not game_completed:
                buttons_y = start_y + grid_height + 30
                total_buttons_width = BUTTON_WIDTH * 2 + BUTTON_GAP
                buttons_start_x = (screen.get_width() - total_buttons_width) // 2

                prev_level_button = Button("Previous", buttons_start_x, buttons_y, BUTTON_WIDTH, BUTTON_HEIGHT)
                next_level_button = Button("Next", buttons_start_x + BUTTON_WIDTH + BUTTON_GAP, buttons_y, BUTTON_WIDTH, BUTTON_HEIGHT)

                if level > 0:
                    prev_level_button.draw(screen)
                if level < MAX_LEVEL - 1:
                    next_level_button.draw(screen)

            pygame.display.flip()

        # event handling
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

            if not game_completed and event.type == pygame.MOUSEBUTTONDOWN and event.button == 1:
                if level_completed:
                    # centering buttons
                    buttons_y = start_y + grid_height + 30
                    total_buttons_width = BUTTON_WIDTH * 2 + BUTTON_GAP
                    buttons_start_x = (screen.get_width() - total_buttons_width) // 2

                    prev_level_button = Button("Previous Level", buttons_start_x, buttons_y, BUTTON_WIDTH, BUTTON_HEIGHT)
                    next_level_button = Button("Next Level", buttons_start_x + BUTTON_WIDTH + BUTTON_GAP, buttons_y, BUTTON_WIDTH, BUTTON_HEIGHT)

                    if level < MAX_LEVEL - 1 and next_level_button.rect.collidepoint(event.pos):
                        level += 1
                        rows, cols, start_x, start_y, grid_width, grid_height = initialize_level()
                    elif level > 0 and prev_level_button.rect.collidepoint(event.pos):
                        level -= 1
                        used_images.clear()
                        rows, cols, start_x, start_y, grid_width, grid_height = initialize_level()
                else:
                    mouse_pos = event.pos
                    for idx in range(len(cards)):
                        row = idx // cols
                        col = idx % cols
                        x = start_x + col * (CARD_WIDTH + MARGIN)
                        y = start_y + row * (CARD_HEIGHT + MARGIN)
                        rect = pygame.Rect(x, y, CARD_WIDTH, CARD_HEIGHT)
                        if rect.collidepoint(mouse_pos):
                            if card_states[idx] == "hidden" and len(flipped_indices) < 2:
                                card_states[idx] = "flipped"
                                flipped_indices.append(idx)
                            break

        # match checking 
        if len(flipped_indices) == 2 and wait_time == 0:
            first, second = flipped_indices
            if cards[first] == cards[second]:
                card_states[first] = "matched"
                card_states[second] = "matched"
                flipped_indices.clear()
            else:
                wait_time = pygame.time.get_ticks() + 1000

        # flipping back unmatched cards after delay
        if wait_time > 0 and pygame.time.get_ticks() >= wait_time:
            for idx in flipped_indices:
                if card_states[idx] != "matched":
                    card_states[idx] = "hidden"
            flipped_indices.clear()
            wait_time = 0

        clock.tick(30)

    pygame.quit()

if __name__ == "__main__":
    main()
